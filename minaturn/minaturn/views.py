import json
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_http_methods
from django.shortcuts import get_object_or_404
from .models import Queue, QueueEntry


@csrf_exempt
def join_queue(request):
    if request.method == "POST":
        try:
            data = json.loads(request.body.decode("utf-8"))
            queue = get_object_or_404(Queue, id=data["queue_id"])

            entry = QueueEntry.objects.create(
                msisdn=data["msisdn"],
                queue=queue,
                left=False
            )
            return JsonResponse({"id": str(entry.id), "status": "joined"})
        except (KeyError, json.JSONDecodeError):
            return JsonResponse({"error": "Invalid request data"}, status=400)

    return JsonResponse({"error": "POST only"}, status=400)

@csrf_exempt
@require_http_methods(["DELETE"])
def delete_queue(request, queue_id):
    try:
        queue = Queue.objects.get(id=queue_id)
    except Queue.DoesNotExist:
        return JsonResponse({"error": "Queue not found"}, status=404)

    # Optionally, also delete all queue entries
    QueueEntry.objects.filter(queue_id=queue_id).delete()
    queue.delete()

    return JsonResponse({"success": True, "queue_id": str(queue_id)})

@csrf_exempt
@require_http_methods(["POST"])
def flush_queue(request, queue_id):
    try:
        queue = Queue.objects.get(id=queue_id)
    except Queue.DoesNotExist:
        return JsonResponse({"error": "Queue not found"}, status=404)

    deleted_count, _ = QueueEntry.objects.filter(queue_id=queue_id).delete()

    return JsonResponse({
        "success": True,
        "queue_id": str(queue.id),
        "flushed_entries": deleted_count
    })


@csrf_exempt
@require_http_methods(["POST"])
def leave_queue(request, queue_id, msisdn):
    try:
        entry = QueueEntry.objects.get(queue_id=queue_id, msisdn=msisdn, left=False)
        entry.left = True
        entry.save()
        return JsonResponse({"success": True, "msisdn": msisdn, "queue_id": queue_id})
    except QueueEntry.DoesNotExist:
        return JsonResponse({"error": "Entry not found or already left"}, status=404)


@require_http_methods(["GET"])
def get_status(request, queue_id, msisdn):
    try:
        entry = QueueEntry.objects.get(queue_id=queue_id, msisdn=msisdn)
        return JsonResponse({
            "msisdn": entry.msisdn,
            "queue_id": queue_id,
            "status": entry.status,
            "left": entry.left,
            "joined_at": entry.joined_at.isoformat(),
            "started_at": entry.started_at.isoformat() if entry.started_at else None,
            "served_at": entry.served_at.isoformat() if entry.served_at else None
        })
    except QueueEntry.DoesNotExist:
        return JsonResponse({"error": "Entry not found"}, status=404)


@csrf_exempt
@require_http_methods(["PUT"])
def update_status(request, queue_id, msisdn):
    try:
        entry = QueueEntry.objects.get(queue_id=queue_id, msisdn=msisdn)
        data = json.loads(request.body)
        status = data.get("status")
        if status not in [choice[0] for choice in QueueEntry.Status.choices]:
            return JsonResponse({"error": "Invalid status"}, status=400)
        entry.status = status
        entry.save()
        return JsonResponse({
            "success": True,
            "msisdn": entry.msisdn,
            "queue_id": queue_id,
            "status": entry.status
        })
    except QueueEntry.DoesNotExist:
        return JsonResponse({"error": "Entry not found"}, status=404)
    except json.JSONDecodeError:
        return JsonResponse({"error": "Invalid JSON body"}, status=400)

def queue_position(request, queue_id, msisdn):
    try:
        entry = QueueEntry.objects.get(queue_id=queue_id, msisdn=msisdn, left=False)
    except QueueEntry.DoesNotExist:
        return JsonResponse({"error": "Not in queue"}, status=404)

    # Position = count of people who joined earlier and havenâ€™t left
    position = (
        QueueEntry.objects.filter(queue_id=queue_id, left=False, joined_at__lt=entry.joined_at)
        .count()
        + 1
    )

    return JsonResponse({
        "msisdn": msisdn,
        "queue_id": str(queue_id),
        "position": position
    })

@csrf_exempt
def create_queue(request):
    try:
        data = json.loads(request.body)
        name = data.get("name")
        description = data.get("description", "")

        if not name:
            return JsonResponse({"error": "name is required"}, status=400)

        # Create Queue (id will be auto-generated by ShortUUIDField)
        queue = Queue.objects.create(name=name, description=description)

        return JsonResponse({
            "success": True,
            "queue_id": str(queue.id),
            "name": queue.name,
            "description": queue.description,
            "created_at": queue.created_at.isoformat()
        }, status=201)

    except Exception as e:
        return JsonResponse({"error": str(e)}, status=500)

@require_http_methods(["GET"])
def all_queues_with_entries(request):
    queues = Queue.objects.all()
    result = []

    for queue in queues:
        entries = queue.items.all().order_by("joined_at")  # related_name='items'
        result.append({
            "queue_id": str(queue.id),
            "name": queue.name,
            "description": queue.description,
            "created_at": queue.created_at.isoformat(),
            "entries": [
                {
                    "msisdn": entry.msisdn,
                    "full_name": entry.full_name,
                    "joined_at": entry.joined_at.isoformat(),
                    "left": entry.left,
                    "status": entry.status,
                    "started_at": entry.started_at.isoformat() if entry.started_at else None,
                    "served_at": entry.served_at.isoformat() if entry.served_at else None
                } for entry in entries
            ]
        })

    return JsonResponse({"queues": result})


"""
For a given queue, we need the time to AVG_TIME_TO_PROCESS. 

Example:
 - A user joins the queue at 10:00 AM
 - The user is processed at 10:30 AM
 - The user gets served at 10:45 AM
Time to process for this user = 15 minutes

Do this for all users in the queue IN THE LAST 30 MINUTES
This will help us understand the average time to process a user in the queue.
This can be used to estimate the time for the next user in the queue.


"""